# -*- coding: utf-8 -*-
"""Bisseccao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ol18ujexavY1LdLCEbTAPmrWgFVeCYi1
"""

import math
import numpy as np
import matplotlib.pyplot as plt
from sympy import *

#metodo da bisseccao
def biss(f,x_left,x_right, switch=1,tol=1.0e-9):
  #definir a tolerancia
  #tol = 1*10**-4
  #primeiro calcular as funcoes de cada valor inicial
  f_left = f(x_left)
  if f_left == 0.0: return x_left
  f_right = f(x_right)
  if f_right == 0.0: return x_right

  #checar se o intervalo contem a raiz
  if f_left*f_right > 0:
    return "tente outros valores iniciais"
  #definir o numero de iterações
  n = int(math.ceil(math.log(abs(x_right - x_left)/tol)/math.log(2.0)))

  #loop para achar a raiz
  for _ in range(n):

        x_m = (x_left + x_right)/2
        f_m = f(x_m)

        if f_m == 0.0: return x_m
        if np.sign(f_m) == np.sign(f_right): x_right = x_m; f_right = f_m
        else: x_left = x_m; f_left = f_m
  
  #retornar o ultimo encontrado      
  return (x_left + x_right)/2


#metodo de newthon-r
def newt(f,df,x):
  fx = f(x)
  if fx == 0: return x
  dfx = df(x)
  i = 0

  while fx != 0:
    x = x - fx/dfx 
    fx = f(x)
    dfx = df(x)
    i += 1
  return fx, x, i

def f(x): return 20.0*math.acos(1-(x/2)) - 5*(2-x)*(math.sqrt(4*x-x**2)) - 8.5
def df(x): return 10*math.sqrt(-(x-4)*x)

print("using bisection Method")
x = biss(f, 0.0, 1.0)
print("x =", "{}".format(x))
print("-----")
print("using Newthon-R. Method")
f_,x2,it = newt(f, df, 1.0)
print("x =", "{}".format(x2))
print("f(x)={}".format(f_))
print("iterations = {}".format(it))

